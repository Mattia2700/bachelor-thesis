\chapter{Planning integration}

Last, but not least, (?) there is the planning part integration, done by Filippo Rossi\footnote{There will not be any further explanation, since the entire project was already described in \autoref{sub:planning}}. What was described in the previous chapters leads (?) to a working version of the project, but has not any practical use, because you need to set where you want the robot to go. Entertaining but useless (?). This is the goal of this chapter: add some mission the robot needs to complete, without any human interaction directly on the robot (?).

\section{Modifications from original planning}

When the planning was developed, Filippo could not receive any feedback from us, since we had some other challenges to face, like making the robots to move autonomously. So, in response, the planning has come as a general workspace to which we can add some modification to meet our specific needs.

\subsection*{Correct waypoint coordinates}

Thanks to Filippo's waypoints extractor and \code{cvat} (?) software, all the required information could be found in a JSON file: when the robot is told to move in a certain room, the only operation to be done (?) is searching its name in the file and get the corresponding coordinates, but the mesh used for generating those waypoints is not the same of the real environment.
Thanks to Blender (cite (?)), after loading the planning mesh and the map used by the navigation system, I (?) was able to find some modification I can bring to get a better result: turning the mesh by {\bf 135 degrees} anticlockwise around the Z axis, scaling up the mesh by {\bf 1.0925\%} on the Y axis, and translating it {\bf 6.82099667587} on the X axis and {\bf 8.7179839194} on the Y axis. Luckily, when doing this on the entire mesh is like doing it to its own points, which is the same of doing it to the singular waypoints, without needing to repeat the annotation process from the beginning: this was done with a Python script (numpy?, matrixes? "do, do, do" (?)).

\subsection*{Change JSON structure}

Then, since the JSON (?) was written as a list of dictionaries, it would be required to iterate over every element and search for the one with the searched name, and if they match, then it is possible to get the coordinates. Instead, I modified the file to be a dictionary, where each key represents the name of the room, and its respective value is a dictionary containing all the data related\footnote{related to that room}: room center and boundaries coordinates.

\subsection*{Remove a stub node from execution}

Currently, the only action supported is \code{ugv\_move}.
For testing purposes, some nodes were added to simulate \Acrshort{ugv}s and \Acrshort{uav}s: they were also started at the beginning of the execution, but one of these now has its real implementation, so its stub one has been removed from the execution. (?)

\section{Task executor}

Three nodes have been created to let the robot moves autonomously: 
\begin{itemize}
    \item a {\bf move client} that consists of two nodes executed in the same process, but in different threads, in order to listen and set the new destination of the robot
    \item a {\bf pose server} which is a service server node responsible for returning the current pose of the robot when requested
\end{itemize}

All the messages exchanged between nodes using services are part of \code{planning\_bridge\_msgs} package. % aggiungere immagini package? parlare anche di planning_bridge? 

\subsection{Move client} %(?)

As the name says, this process is used to move the robot around based on the planning decisions. It could be divided in two parts:

\begin{itemize}
    \item a planning client, which is always listening for the next goal to be reached
    \item a navigation client responsible for setting the destination and let the robot reach it
\end{itemize}

$$  
    PLANNING \;\; CLIENT \; 
        \autorightleftharpoons{float32 x, y, z}{bool success} \;
    NAVIGATION \;\; CLIENT
$$ 
    
% add it as a figure? add also planning server and navigation server? (?)

\subsubsection*{Planning client}

%inserire immagine codice (?)

It is an action client of \code{plansys2} (?), which means that after setting a goal it would send back feedback and the result of that action at the end. When a new task has been created and started, the planning server would call the \code{do\_work()} method of the designed client, to let it know a new job needs to be completed.
Inside this method the client transforms the room name in coordinates and passes the goal to the navigation client if it was not already set, making use of a custom service; after that, it asks its current position to the pose server (with another service) and uses it to set both the initial and current position; then, it returns a percentage of completion of the task. This method is called continuously until the task is completed, so if the initial position is already set (and as a result also the goal), it would continue to ask its current position in order to calculate the euclidean and return a new percentage of completion; because the path to reach the destination might not be a straight line and the distance used is the euclidean one, it could happen the current distance is greater than the initial one: in this case, they are swapped to keep 0 as the lower bound of completion. (?)

\subsubsection*{Navigation client}

This is both an action client and a service server: the first is used to receive the coordinates from the planning client and  uses the second one to connect to the navigation action server and set the given destination. It is only called the first time a new task is created.

\subsection{Pose server} %(?)
\label{sub:pose}

The pose server acts like a service server: when it receives a request, it returns the current position of the robot. In order to achieve it, some other calculations need to be done: we are interested in \code{base\_link} frame and the only transformation with it as a child frame is the \code{odom} one, but this is not the global one, the same used for waypoint coordinates. There is the need to express it from the \code{map} frame perspective, and luckily such a transformation is available thanks to \Acrshort{amcl} node. 
Thanks to \code{tf\_monitor}\cite{tfexample} used as a template, it was possible to obtain the correct transformation, fusing the required two.

$$
    PLANNING \;\; CLIENT \; 
        \autorightleftharpoons{\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;}{float32 x, y, z} \;
    POSE \;\; SERVER
$$ 

% In order to have a better control over the task executions, it has been defined two services, in order to communicate and synchronize the robot action with the planning server. % continue




