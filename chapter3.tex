\chapter{Working in a real environment}

\label{cha:realworld}

When using a real environment, you need a real robot. In our department there is the following one:

{\bf INSERT PIC HERE}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.3\textwidth]{images/nav2\_architecture}
  \caption{The, so called, shelfino robot}
  \label{fig:shelfino}
\end{figure}



\section{Shelfino setup} 

\subsection{Adapting existing code}

The hardware interface was already developed by some research students in the last years, but they are no longer here. My first idea was to develop some ROS nodes that would connect to encoders, motors drivers and lidar, but I couldn't get so much information about brands or manifestations of the hardware.

So I decided to adapt the code to ROS2, but I couldn't get it to work, mainly because some features were not implemented in the same way as they were originally in \Acrshort{ros}1. For example, in \Acrshort{ros}1 there was a needing to include {\it C++ Boost Library} in order to use {\it shared pointers}, {\it mutex and lock} and some other features; later on, these libraries were included in the standard library, so there is no need to include them anymore.
The problems come in when the included libraries are custom ones designed specifically for \Acrshort{ros}1, and not ported similarly in \Acrshort{ros}2, like {\bf Callback Queues}\footnote{Add more information}\cite{migrationguide}.

Later on, after spending (some) hours trying to adapt the code with poor results, I decided to try another solution: using a \Acrshort{ros}2 package called {\it ros1\_bridge}. Since both \Acrshort{ros}1 and \Acrshort{ros}2 use an own network to deliver messages, it is possible to use a node that listens to (?) both(?) and when something is received from one side, it is sent to the other one: in this way it is possible to run the existing code as it is on a \Acrshort{ros}1 node, and interact with it from a \Acrshort{ros}2 workspace.

In order to run both \Acrshort{ros}1 and \Acrshort{ros}2 nodes on the same machine\footnote{or Docker container} I need the same version of Ubuntu. And since I need to use \Acrshort{ros}2 Foxy, that runs on Ubuntu 20.04, because of planning libraries, I have to use \Acrshort{ros}1 Noetic, but that code was written for the previous version\footnote{\Acrshort{ros}1 Noetic, for Ubuntu 18.04}: luckily, after installing the next version of the dependencies, there were no compatibility issues.

\subsection{Existing nodes}
\label{subsec:nodes}

I created a specific launch file\footnote{A launch file is a file containing information about which nodes, eventually with some parameters, should be started when passed to {\it roslaunch} (\Acrshort{ros}1) or {\it ros2 launch} (\Acrshort{ros}2), instead of running each node singularly.}, in order to start the 3 required nodes\footnote{The bold text indicates a custom package; an italic one is a ROS-provided package}:

\begin{itemize}
    \item {\it base2laser\_bcast}\footnote{bcast stands for broadcast}
    \item {\bf hw\_interface}
    \item {\bf odom\_node}
\end{itemize}

\lstset{
    basicstyle=\ttfamily,
    columns=fullflexible,
    showstringspaces=false,
    commentstyle=\color{gray}\upshape
  }
  
  \lstdefinelanguage{XML}
  {
    morestring=[b]",
    morecomment=[s]{<?}{?>},
    stringstyle=\color{Orange},
    identifierstyle=\color{Red},
    keywordstyle=\color{Black},
    morekeywords={type,pkg,name,args}% list your attributes here
  }

\subsubsection{base2laser\_bcast}

\begin{lstlisting}[language=XML]
    <node pkg="tf" type="static_transform_publisher" name="base2laser_bcast"
        args="0. 0 0.45 0 0 0 base_link base_laser 100" />
\end{lstlisting}

This is a node of the \code{tf}\footnote{tf is a package that lets the user keep track of multiple coordinate frames over time [...] and lets the user transform points, vectors, etc between any two coordinate frames at any desired point in time.\cite{tf}} package of \Acrshort{ros}1 called \code{static\_transform\_publisher}\footnote{Publish a static coordinate transform to tf using an x/y/z offset in meters and yaw\/pitch/roll in radians. [...]. The period, in milliseconds, specifies how often to send a transform.}, with a custom name. What it does, as the name says, is broadcasting a transformation between base\_link and base\_laser every \code{100ms} with: base\_link is the root one and base\_laser is differing from it by a translation of (x: 0, y: 0, z: 0.45) and a rotation of (roll: 0, pitch: 0, yaw: 0). So when some points are returned by the lidar, we know they refer to the given position and rotation, and should be considered (and eventually translated) when using these data for other calculations.

\subsubsection{hw\_interface}

It is a node designed to interface with the underlying hardware, thanks to the custom \code{hardwareglobal interface}\footnote{Helper class using a ZeroMQ framework to deliver messages between the hardware (client) and the server running on the BeagleBone, that keeps track of the recevied data and make it accessible using the class method.} library previously developed by the researchers.

In other words, using the just described interface, it reads the data coming from the encoders, lidar and tracking camera and make them available as \Acrshort{ros}2 topics (\code{/encoders, /scan, /t265}). It also subscribes to a \code{/cmd\_vel} topic from which reads the requested linear and angular velocity and dispatches them to the motors of the robot in the right way.

\subsubsection{odom\_node}

This node makes use of the information received from the encorders (tick updates) and tracking camera topics, to calculate odometry, which represents the rotation and the translation of the robot from where it started. These new information are then published both as a message in a topic and as a transformation in the tf tree, the one between odom\_frame and base\_link, to describe the frame where the robot is. \\\\