% Parlare del tipo di robot, diff drive, ecc. (?)

\chapter{Working in a real environment}
\label{cha:realworld}

First thing we need is the robot: this projects makes use of the one shown in \autoref{fig:shelfino}, and it comes from \acrfull{disi} of University of Trento.

\bigskip

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{images/shelfino}
  \caption{The, so called, \textit{shelfino (one)} robot}
  \label{fig:shelfino}
\end{figure}

\section{Shelfino setup} 

\subsection{Adapting existing code}

The \textbf{hardware interface} was already developed by some research students in the last years, but they are no longer here. The original idea was to develop some ROS nodes that would connect to \textbf{encoders}, \textbf{motors drivers} and \textbf{lidar}, but specific information about brands or manufacturers of some of these components were not provided.

Another attempt was trying to rewrite the code in ROS2: it was not straightforward, and it did not work at the end, since the libraries used refers to a not well-known network infrastructure. Moreover, some feature has not been ported \textbf{equally} to \acrshort{ros}2, leading to some potential \textbf{differences} from the original code.

\subsection{\acrshort{ros}1 Bridge}

The final attempt involved the use of a \acrshort{ros}2 package called \textit{ros1\_bridge}. Since both \acrshort{ros}1 and \acrshort{ros}2 use their own \textbf{local network} to deliver messages, you can create a node that \textbf{listens to both networks} and when something is received from one side, it is sent to the other one: in this way it is possible to run the \textbf{existing code as it is} on a \acrshort{ros}1 node (with its dependencies), while making use of its topics and services on a \acrshort{ros}2 workspace at the same time.

But, in order to run both \acrshort{ros}1 and \acrshort{ros}2 nodes on the same machine (or Docker container), they need the same version of Ubuntu. \textbf{\acrshort{ros}2 Foxy} version is mandatory because of planning libraries, and runs only on \textbf{Ubuntu 20.04}, so also \acrshort{ros}1 has to use it; the original code, however, was written for the previous version (\acrshort{ros}1 Melodic, running only on Ubuntu 18.04), but luckily it runs without problems on the new one\footnote{The biggest change was introducing the support for Python 3}, \textbf{\acrshort{ros}1 Noetic} (for the same OS version).

To be more precise, it was used the \code{dynamic\_bridge} of this package, instead of \code{parametric\_bridge} and \code{static\_bridge} ones: with the first one you can choose what topics or services you want to bridge, but it has some bugs and does not work well, while the second one needs to be compiled every time there are some changes; the dynamic one, instead, adapts itself.

\subsection{Existing nodes explained}
\label{subsec:nodes}

In order to start the required nodes, a custom launch file was created. A launch file is a file containing information about \textbf{which nodes}, eventually with some \textbf{parameters}, should be \textbf{started} when the system is launched, instead of doing it one by one. Three nodes are inside this launch file:

\begin{itemize}
    \item \code{lidar\_position}
    \item \code{hw\_interface}
    \item \code{odom\_node}
\end{itemize}

\subsubsection{lidar\_position} % forse togliere e forse  mettere 0.43 (?), dire che Ã¨ stata fatta su ros2 ora

\begin{lstlisting}[
  label={lst:lidarpos},
  language=xml,
  style=xmlStyle
  ]
  <node pkg="tf" type="static_transform_publisher" name="lidar_position"
    args="0 0 0.45 0 0 0 base_link base_laser 10" />
\end{lstlisting}

This is a node (with a custom name) of the \code{tf} package of \acrshort{ros}1, \textit{a package that lets the user keep track of multiple coordinate frames over time [...] and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time}. \cite{tf} The node executable is called \code{static\_transform\_publisher} and it is used to \textit{publish a static coordinate transform to tf using an x/y/z offset in meters and roll/pitch/yaw in radians [...]. The period, in milliseconds, specifies how often to send a transform}. \cite{tf} 
As \autoref{lst:lidarpos} shows, here it is used to describe the \textbf{transformation} between \code{base\_link}, the root frame (located on the ground under the robot, in the origin) and \code{lidar\_link} (0.45 meters above) every \code{10ms}. So when some points are returned by the laser scans, we also know the height, not otherwise specified, since it is a 2D scan. For this project, only frequency was raised, from one message every \code{100ms} to one every \code{10ms}.

\subsubsection{hw\_interface}

It is a node designed to interface with the \textbf{underlying hardware}, thanks to the custom \code{hardwareglo\-balinterface} library previously developed by the researchers. It is a \textbf{helper class} using a \textbf{ZeroMQ framework} to deliver messages between the hardware (client) and the server running on the BeagleBone, that keeps track of the received data and make it accessible using the class methods.

Basically, using the just described interface, it reads the data coming from \textbf{encoders}, \textbf{lidar} and \textbf{tracking camera} and make it available as \acrshort{ros}2 topics (\code{/encoders, /scan, /t265}). It also subscribes to a \code{/cmd\_vel} topic from which reads the requested \textbf{linear} and \textbf{angular velocities} and dispatches them to the motors of the robot accordingly.

\subsubsection{odom\_node}

This node makes use of the information received from the \textbf{encoders topic} about the rotation of the wheels and \textbf{tracking camera topic}\footnote{A tracking camera is used in addition to wheels rotation to avoid odometry drift. If not using a tracking camera, when the robot is facing a wall and the wheels continue to rotate (and obviously the robot will not move), the odometry will tell the opposite, that it is still moving. When using it, if the robot is moving, certainly what the tracking camera perceives change, otherwise it will not, and it can be used to avoid what described above.} to calculate \textbf{odometry}, which represents an estimation of the \textbf{position} and the \textbf{rotation} of the robot from where it started. These new information are then published both as a message in a topic, and as a transformation between \code{odom\_frame} and \code{base\_link}, employed by the \textbf{navigation system} as described in \autoref{cha:navigation}.